import os
import pickle
import re
from datetime import datetime
from io import BytesIO
from typing import Generator, Iterable

import docx
import openai
import requests
from bson import ObjectId
from docx import Document
from docx.enum.text import WD_BREAK, WD_PARAGRAPH_ALIGNMENT
from docx.shared import Pt, RGBColor
from openpyxl import Workbook
from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN
from pptx.util import Inches, Pt
from rake_nltk import Rake
from sumy.nlp.tokenizers import Tokenizer
from sumy.parsers.plaintext import PlaintextParser
from sumy.summarizers.text_rank import TextRankSummarizer

from app.config import Config
from app.models.mongoClient import MongoClient
from app.utils.common import Common
from app.utils.llm.llm_highlights import generate_highlights
from app.utils.llm.llm_summarizer import summarize_text

from ..utils.document import add_hyperlink


class SummaryService:
    # PUNKT_SENTENCE_TOKENIZER = nltk.data.load("app/models/english.pickle")
    # nltk.download('punkt')
    # nltk.download('stopwords')
    tokenizer = pickle.load(open(("app/models/sentenceTokenizer.pkl"), "rb"))
    texts_to_be_removed = [
        "Follow @htshowbiz for more",
        "Get live Stock Prices from BSE, NSE, US Market and latest NAV, portfolio of Mutual Funds, calculate your tax by Income Tax Calculator, know marketâ€™s Top Gainers, Top Losers & Best Equity Funds.",
        "Like us on Facebook and follow us on Twitter.",
        "(Representative image)",
        "Later facebook twitter youtube snapchat flipboard close: There was a problem processing your signup",
        "please try again later Facebook Twitter Youtube Snapchat Flipboard CLOSE",
        "_",
        "Bse quotes and sensex are real-time and licensed from the bombay stock exchange.",
        "All times stamps reflect ist (indian standard time)",
        "Bombay stock exchange: BSE Quotes and Sensex are real-time and licensed from the Bombay Stock Exchange.",
        "National stock exchange: NSE Quotes and Nifty are also real time and licenced from National Stock Exchange.",
        ";",
        "|",
        "Figure",
        "Advertisement",
        "Getty Images",
        "TAGS",
        ":",
        "|",
        "\n",
        "\\",
        "FRESH GUARD",
        "/(Except for the headline, this story has not been edited by NDTV staff and is published from a syndicated feed./)",
        "Also Read |",
    ]

    def itemized_summary_gpt(self, ki_ids, sentence_count):
        """
        The `itemized_summary_gpt` function generates or retrieves itemized summaries for a list of
        knowledge item IDs.
        
        Args:
          ki_ids: ki_ids is a list of KI IDs. These IDs are used to retrieve the corresponding KI
        (Knowledge Item) documents from the MongoDB collection.
          sentence_count: The `sentence_count` parameter is the number of sentences you want the summary
        to contain. It determines the length of the summary generated by the `summarize_text` function.
        """
        ki_collection = Config.MONGO_KI_COLLECTION

        m_db = MongoClient.connect()

        # Convert kiIds to a list of ObjectIDs
        ki_ids_object_id = list(map(ObjectId, ki_ids))

        ki_iterable = m_db[ki_collection].find({"_id": {"$in": ki_ids_object_id}})

        for idx, ki in enumerate(ki_iterable):
            ki_description = ""
            
            if not ki:
                yield ki_description, idx, None, False

            ki_description = ki["description"]
            itemized_summary = ki["summary"]
            
            if len(itemized_summary) > 0:
                print("Found summary from DB!")
                text_summary = itemized_summary
            else:
                print("Generating summary!")
                text_summary = summarize_text(ki_description)
                if text_summary == "":
                    text_summary = ki_description
                # Store the text_summary for next time quick access
                m_db[ki_collection].update_one(
                    {"_id": ObjectId(ki["_id"])}, {"$set": {"summary": text_summary}}
                )

            # yield text_summary, True
            yield text_summary, ki["_id"], ki["title"], True

    def consolidated_summary(ki_ids: Iterable[str], sentence_count_itemized: int, num_required_words: int, verbose: bool = False):
        """
        The function `consolidated_summary` takes in a list of ki_ids, a sentence_count_itemized, a
        num_required_words, and an optional verbose parameter. It generates a consolidated summary by
        concatenating the ki summaries and splitting them into slices. It then uses OpenAI's
        text-davinci-003 model to generate paragraphs and titles based on the concatenated summaries.
        The function returns a response object containing the generated paragraphs, title options, and
        the generated date.
        
        Args:
          ki_ids (Iterable[str]): A list of KI IDs, which are identifiers for the knowledge items.
          sentence_count_itemized (int): The parameter `sentence_count_itemized` specifies the number of
        sentences to include in each itemized summary.
          num_required_words (int): The parameter `num_required_words` specifies the desired number of
        words for the summary.
          verbose (bool): The `verbose` parameter is a boolean flag that determines whether or not to
        print additional information during the execution of the function. If `verbose` is set to
        `True`, the function will print out additional details. If `verbose` is set to `False` (the
        default value), no additional. Defaults to False
        
        Returns:
          The function `consolidated_summary` returns a dictionary `response` containing the following
        keys:
        - "paragraphs": a list of paragraphs generated by OpenAI based on the input summaries
        - "titleOptions": a list of short snappy titles generated by OpenAI based on the generated
        paragraphs
        - "generatedDate": the current date and time when the response was generated
        - "openAi
        """
        ki_summary_arr = []
        concatenated_summary_arr = []

        for ki_summary, _, _ in SummaryService()._summarize_sumy_text_rank(
            ki_ids, sentence_count_itemized
        ):
            ki_summary_arr.append(ki_summary)
            # print(ki_summary, idx)

        # slice_length = (2049 - prompt_num_tokens) * 4
        # start_index = 0
        # end_index = start_index + slice_length

        # while start_index == 0 or end_index < len(concatenated_summary):
        #     concatenated_summary_split = concatenated_summary[start_index : end_index]
        #     concatenated_summary_arr.append(concatenated_summary_split)

        #     start_index = end_index + 1
        #     end_index = start_index + slice_length

        # total_num_words = len(re.findall(r'\w+', "".join(ki_summary_arr)))
        max_allowed_tokens = 2049
        # completion_num_tokens = 300
        prompt = (
            f"\n\nprompt - Provide summary of the above in {num_required_words} words"
        )
        prompt_num_tokens = len(prompt) // 4

        # Create slices using ki summaries
        # No slice should contain part of a KI summary
        # Either it will contain the entire KI summary or won't
        last_ki_summary_idx = 0
        # last_concatenated_summary_idx = 0
        while last_ki_summary_idx < len(ki_summary_arr):
            current_concatendated_summary = ""
            while last_ki_summary_idx < len(ki_summary_arr) and (
                len(current_concatendated_summary) // 4 + prompt_num_tokens
                #  + completion_num_tokens
                + len(ki_summary_arr[last_ki_summary_idx]) // 4
                <= max_allowed_tokens
            ):
                current_concatendated_summary += ki_summary_arr[last_ki_summary_idx]
                last_ki_summary_idx += 1
            concatenated_summary_arr.append(current_concatendated_summary)
            print(current_concatendated_summary + "\n\n")
            print("Length", len(current_concatendated_summary))

        paragraphs = []
        response = {
            "paragraphs": [],
            "titleOptions": [],
            "generatedDate": "",
            "openAiOriginalResponses": [],
        }

        print("\n\nconcatenated_sumarry_arr\n\n", concatenated_summary_arr, "\n\n")
        for concatenated_summary_split in concatenated_summary_arr:
            print("\n\nfinal prompt", concatenated_summary_split + prompt + "\n\n")
            openai_resp = openai.Completion.create(
                model="text-davinci-003",
                prompt=concatenated_summary_split + prompt,
                temperature=0.7,
                max_tokens=int(int(num_required_words) * 1.5),
                top_p=1.0,
                frequency_penalty=0.0,
                presence_penalty=1,
            )
            # print(openai_resp)
            paragraphs.append(openai_resp["choices"][0]["text"])
            if verbose:
                response["openAiOriginalResponses"].append(openai_resp)

        title_arr = []
        for paragraph in paragraphs:
            openai_resp = openai.Completion.create(
                model="text-davinci-003",
                prompt=paragraph
                + "\n\nprompt - Provide a short snappy title that sums up the above points",
                temperature=0.7,
                max_tokens=60,
                top_p=1.0,
                frequency_penalty=0.0,
                presence_penalty=1,
            )
            title = str(openai_resp["choices"][0]["text"])
            if title.startswith("."):
                title = title[1:].strip()
            title_arr.append(title)

        response["titleOptions"] = title_arr
        response["paragraphs"] = paragraphs
        response["generatedDate"] = datetime.utcnow()

        return response

    def highlights(self, ki_ids: Iterable[str]):
        """
        The `highlights` function takes a list of ki_ids, retrieves the corresponding ki objects from a
        MongoDB collection, generates highlights for each ki object if they don't already exist in the
        database, and yields the highlights along with their index.
        
        Args:
          ki_ids (Iterable[str]): The `ki_ids` parameter is an iterable of strings. It represents a
        collection of unique identifiers for the "ki" objects that we want to retrieve highlights for.
        """
        ki_collection = Config.MONGO_KI_COLLECTION

        m_db = MongoClient.connect()

        # Convert kiIds to a list of ObjectIDs
        ki_ids_object_id = list(map(ObjectId, ki_ids))

        ki_iterable = m_db[ki_collection].find({"_id": {"$in": ki_ids_object_id}})

        for idx, ki in enumerate(ki_iterable):
            ki_description = ""

            if not ki:
                yield generate_highlights(ki_description), idx

            ki_description = ki["description"]
            if "highlightsSummary" in ki:
                highlights_summary = ki["highlightsSummary"]
            else:
                highlights_summary = {}

            # If summary already exists in DB then fetch it
            if len(highlights_summary) > 0:
                print("Found highlight from DB!")
                text_highlights = highlights_summary
            else:
                print("Generating highlight!")
                text_highlights = generate_highlights(ki_description)

                # Store the text_summary for next time quick access
                if(text_highlights['suc']==True):

                    m_db[ki_collection].update_one(
                        {"_id": ObjectId(ki["_id"])},
                        {"$set": {"highlightsSummary": text_highlights}},
                    )

            yield text_highlights, idx

    def create_consolidated_ppt(self, request_body):
        """
        The `create_consolidated_ppt` function creates a PowerPoint presentation with a cover page,
        content pages, and a thank you page based on the given request body.
        Ref for slide types:
            0 -> title and subtitle
            1 -> title and content
            2 -> section header
            3 -> two content
            4 -> Comparison
            5 -> Title only
            6 -> Blank
            7 -> Content with caption
            8 -> Pic with caption
        
        Args:
        request_body: The `request_body` parameter is a dictionary that contains the following
        key-value pairs:
        
        Returns:
        the file path of the created PowerPoint presentation.
        
        """

        # Creating presentation object
        root = Presentation()

        # Set slide width and height
        slide_width = 11887200
        slide_height = 6686550
        root.slide_width = slide_width
        root.slide_height = slide_height

        # Heading Page
        #############################

        # Creating slide layout
        first_slide_layout = root.slide_layouts[5]

        # Creating slide object to add
        slide = root.slides.add_slide(first_slide_layout)

        # Set slide dimensions
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        left = top = 0
        img_path = "app/static/ppt_images/cover_export.jpg"
        pic = slide.shapes.add_picture(
            img_path, left, top, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Adding title and subtitle in slide
        # i.e. first page of slide
        title_shape = slide.shapes.title
        title_shape.text = "Consolidated Summary"
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            255, 255, 255
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(43)  # Set title font size

        # Change the position of the title box
        title_shape.left = Inches(0.85)
        title_shape.top = Inches(2.52)
        title_shape.width = Inches(4)  # Set the width to 4 inches
        title_shape.height = Inches(2)  # Set the width to 2 inches
        title_shape.text_frame.paragraphs[0].font.bold = True

        # Content pages
        ##########################

        # Function to add a new slide with given title and content

        def add_new_slide(title, content):
            slide_layout = root.slide_layouts[5]  # Title and content layout
            slide = root.slides.add_slide(slide_layout)
            slide.slide_width = slide_width
            slide.slide_height = slide_height

            # Add background image
            img_path = "app/static/ppt_images/inside_export.jpg"
            pic = slide.shapes.add_picture(
                img_path, 0, 0, width=slide_width, height=slide_height
            )

            # This moves it to the background
            slide.shapes._spTree.remove(pic._element)
            slide.shapes._spTree.insert(2, pic._element)

            # Set title text
            title_shape = slide.shapes.title
            title_shape.text = title
            # title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(255, 255, 255)  # Set title color to white
            title_shape.text_frame.paragraphs[0].font.size = Pt(
                24
            )  # Set title font size
            # Set title font to Roboto
            title_shape.text_frame.paragraphs[0].font.name = "Roboto"
            title_shape.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
            title_shape.text_frame.paragraphs[0].font.bold = True

            # Move 0.25 inches to the right horizontally
            title_shape.left = Inches(0.28)
            title_shape.top = Inches(0.26)  # Move 0.16 inches down vertically
            title_shape.width = Inches(11)  # Set the width to 4 inches
            title_shape.height = Inches(0.5)  # Set the width to 0.75 inches

            textbox = slide.shapes.add_textbox(
                Inches(0.28), Inches(1.26), Inches(12.44), Inches(5.3)
            )
            textbox.text_frame.paragraphs[0].text = content.strip()
            textbox.text_frame.paragraphs[0].font.name = "Roboto"
            textbox.text_frame.paragraphs[0].font.size = Pt(12)
            textbox.text_frame.paragraphs[0].font.color.rgb = RGBColor(72, 88, 95)
            textbox.text_frame.word_wrap = True

        # Example text that may be too big for a single slide
        # example_text = """Artificial Intelligence (AI) refers to the simulation of human intelligence in machines that are programmed to perform tasks and exhibit behavior that typically requires human intelligence. AI is a multidisciplinary field that combines computer science, mathematics, statistics, psychology, and other disciplines to develop algorithms and systems capable of learning, reasoning, problem-solving, and decision-making.AI encompasses a broad spectrum of techniques and approaches, ranging from traditional rule-based systems to advanced machine learning algorithms. Rule-based systems rely on predefined rules and logic to process information and make decisions, while machine learning algorithms enable computers to learn from data and improve their performance over time.Machine learning, a subset of AI, focuses on the development of algorithms that allow computers to automatically learn from and make predictions or decisions based on data. This is achieved through the use of statistical techniques and mathematical models that enable machines to recognize patterns, classify information, and make accurate predictions or decisions.There are different types of machine learning, including supervised learning, unsupervised learning, and reinforcement learning. Supervised learning involves training a model on labeled data, where the desired output is known, to make predictions on new, unseen data. Unsupervised learning involves discovering patterns and structures in unlabeled data without specific guidance. Reinforcement learning involves training agents to interact with an environment and learn optimal strategies through a trial-and-error process.AI has numerous applications across various domains, including healthcare, finance, manufacturing, transportation, and entertainment. In healthcare, AI can be used for medical diagnosis, drug discovery, and personalized treatment plans. In finance, AI algorithms can analyze vast amounts of financial data to detect fraud, make investment predictions, and automate trading. In manufacturing, AI enables process optimization, predictive maintenance, and quality control. In transportation, AI powers autonomous vehicles, traffic management systems, and route planning.However, AI also raises ethical and societal concerns. Questions about privacy, bias in algorithms, job displacement, and the overall impact on society need to be addressed. Ensuring responsible and ethical development and use of AI is crucial to harness its potential benefits while minimizing potential risks.In conclusion, AI refers to the development of intelligent machines capable of performing tasks that typically require human intelligence. It encompasses various techniques, with machine learning playing a significant role. AI has broad applications and transformative potential across industries, but careful consideration of ethical implications is essential to ensure its responsible deployment for the benefit of humanity."""
        # consolidated_summary_obj = SummaryService.consolidated_summary(ki_ids, sentence_count_itemized, False)
        # if len(consolidated_summary_obj["paragraphs"][0]) == 0:
        #     del consolidated_summary_obj["paragraphs"][0]

        example_text = "\n".join(request_body["paragraphs"])
        # print("example text", example_text)

        # Check if the example text fits on a single slide
        max_chars_per_slide = 3000
        if len(example_text) <= max_chars_per_slide:
            # Text fits on a single slide
            example_text = example_text.strip()
            add_new_slide("Consolidated Summary", example_text)
        else:
            # Text does not fit on a single slide, split it into multiple slides
            sentences = example_text.split(".")
            current_slide_text = ""
            for sentence in sentences:
                if len(current_slide_text) + len(sentence) + 1 > max_chars_per_slide:
                    # Current slide is full, add a new slide with the accumulated text
                    current_slide_text = current_slide_text.strip()
                    add_new_slide("Consolidated Summary", current_slide_text)
                    current_slide_text = ""
                current_slide_text += sentence + ". "
            if current_slide_text:
                # Add the remaining text to a new slide
                current_slide_text = current_slide_text.strip()
                add_new_slide("Consolidated Summary", current_slide_text)

        # Thank You page
        ######################
        slide_layout = root.slide_layouts[5]  # Title and content layout
        slide = root.slides.add_slide(slide_layout)
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        # Add background image
        img_path = "app/static/ppt_images/thank_you.jpg"
        pic = slide.shapes.add_picture(
            img_path, 0, 0, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Set title text
        title_shape = slide.shapes.title
        title_shape.text = "Thank you for the download"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            89, 100, 116
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(22)  # Set title font size
        title_shape.text_frame.paragraphs[0].font.bold = True
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"

        # Move 0.2 inches to the right horizontally
        title_shape.left = Inches(4.24)
        title_shape.top = Inches(4.19)  # Move 3 inches down vertically
        title_shape.width = Inches(4.52)  # Set the width to 4 inches
        title_shape.height = Inches(0.45)  # Set the width to 2 inches
        # Saving file

        timestamp = datetime.utcnow().timestamp()
        file_name = f"Output_{timestamp}.pptx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, file_name
        )
        root.save(file_path)

        return file_path

    def create_consolidated_docx(self, request_body):
        """
        The function `create_consolidated_docx` creates a consolidated summary document in the form of a
        Word document (.docx) based on the provided request body.
        
        Args:
          request_body: The `request_body` parameter is a dictionary that contains the following keys:
        
        Returns:
          the file path of the saved document.
        """

        # Create a new document
        document = Document()

        # Add a paragraph with the document title
        document.add_paragraph("Consolidated Summary", style="Title")

        def create_summary(title="", content=""):
            # Add a heading for the item
            h = document.add_heading()
            run = h.add_run(title)
            font = run.font
            font.size = Pt(16)

            document.add_paragraph()

            # Add a paragraph for the summary
            p = document.add_paragraph()
            run = p.add_run(content)
            font = run.font
            font.size = Pt(12)

        summary_title = " ".join(request_body["titleOptions"]).strip()
        summary_content = "\n".join(request_body["paragraphs"]).strip()
        create_summary(summary_title, summary_content)

        # Save the document
        timestamp = datetime.utcnow().timestamp()
        file_name = f"Consolidated_Output_{timestamp}.docx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, file_name
        )
        document.save(file_path)

        return file_path

    def create_consolidated_summary_excel(self, request_body):
        """
        The function `create_consolidated_summary_excel` creates an Excel file with a consolidated
        summary based on the provided request body.
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents a file record and contains the following keys:
        
        Returns:
          the file path of the created Excel file.
        """
        
        # print("consolidated summary request body : ", request_body)
        workbook = Workbook()
        sheet = workbook.active
        headers = ["Title", "Summary", "Reference Links", "Generation Date", "Number of Minutes to read"]
        sheet.append(headers)
        # adding data to workbook
        for file_record in request_body:
            row = [
                file_record.get("title", ""),
                file_record.get("summary", ""),
                file_record.get("ref_links", ""),
                file_record.get("gen_date", ""),
                file_record.get("num_min_read", ""),
            ]
            sheet.append(row)
            # print("Data row : ", row)

        timestamp = datetime.utcnow().timestamp()
        file_name = f"consolidated_summary_{timestamp}.xlsx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, file_name
        )
        workbook.save(file_path)
        workbook.close()
        return file_path
        # return ""

    def create_itemized_summary_ppt(self, request_body):
        """
        The `create_itemized_summary_ppt` function creates a PowerPoint presentation with itemized
        summaries based on the given request body.
        Ref for slide types:
            0 -> title and subtitle
            1 -> title and content
            2 -> section header
            3 -> two content
            4 -> Comparison
            5 -> Title only
            6 -> Blank
            7 -> Content with caption
            8 -> Pic with caption
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents an item to be included in the itemized summary PowerPoint presentation. Each
        dictionary should have the following keys:
        
        Returns:
          the file path of the created PowerPoint presentation.
        
        """

        # Creating presentation object
        root = Presentation()

        # Set slide width and height
        slide_width = 11887200
        slide_height = 6686550
        root.slide_width = slide_width
        root.slide_height = slide_height

        # Heading Page
        #############################

        # Creating slide layout
        first_slide_layout = root.slide_layouts[5]

        # Creating slide object to add
        slide = root.slides.add_slide(first_slide_layout)

        # Set slide dimensions
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        left = top = 0
        img_path = "app/static/ppt_images/cover_export.jpg"
        pic = slide.shapes.add_picture(
            img_path, left, top, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Adding title and subtitle in slide
        # i.e. first page of slide
        title_shape = slide.shapes.title
        title_shape.text = "Itemized Summary"
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            255, 255, 255
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(43)  # Set title font size

        # Change the position of the title box
        title_shape.left = Inches(0.85)
        title_shape.top = Inches(2.52)
        title_shape.width = Inches(4)  # Set the width to 4 inches
        title_shape.height = Inches(2)  # Set the width to 2 inches
        title_shape.text_frame.paragraphs[0].font.bold = True

        # Content pages
        ##########################

        # Function to add a new slide with given title and content

        def add_new_slide(title, content, image=""):
            slide_layout = root.slide_layouts[5]
            slide = root.slides.add_slide(slide_layout)
            slide.slide_width = slide_width
            slide.slide_height = slide_height

            # Add background image
            img_path = "app/static/ppt_images/inside_export.jpg"
            pic = slide.shapes.add_picture(
                img_path, 0, 0, width=slide_width, height=slide_height
            )

            # This moves it to the background
            slide.shapes._spTree.remove(pic._element)
            slide.shapes._spTree.insert(2, pic._element)

            # Set title text
            title_shape = slide.shapes.title
            title_shape.text = title.strip()
            # title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(255, 255, 255)  # Set title color to white
            title_shape.text_frame.paragraphs[0].font.size = Pt(
                24
            )  # Set title font size
            # Set title font to Roboto
            title_shape.text_frame.paragraphs[0].font.name = "Roboto"
            title_shape.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
            title_shape.text_frame.paragraphs[0].font.bold = True

            # Move 0.25 inches to the right horizontally
            title_shape.left = Inches(0.28)
            title_shape.top = Inches(0.26)  # Move 0.16 inches down vertically
            title_shape.width = Inches(11)  # Set the width to 4 inches
            title_shape.height = Inches(0.5)  # Set the width to 0.75 inches

            # Set the width and height for the image
            image_width = Inches(3)
            image_height = Inches(3)

            # Download the image from the URL
            if image:
                response = requests.get(image)
                image_content = BytesIO(response.content)

                # Add the image to the slide
                slide.shapes.add_picture(
                    image_content,
                    Inches(0.35),
                    Inches(1.26),
                    width=image_width,
                    height=image_height,
                )

            if image:
                textbox = slide.shapes.add_textbox(
                    Inches(3.7), Inches(1.1), Inches(9), Inches(5.3)
                )
            else:
                textbox = slide.shapes.add_textbox(
                    Inches(0.28), Inches(1.1), Inches(12.44), Inches(5.3)
                )
            textbox.text_frame.paragraphs[0].text = content.strip()
            textbox.text_frame.paragraphs[0].font.name = "Roboto"
            textbox.text_frame.paragraphs[0].font.size = Pt(13)
            textbox.text_frame.paragraphs[0].font.bold = True
            textbox.text_frame.paragraphs[0].font.color.rgb = RGBColor(72, 88, 95)
            textbox.text_frame.word_wrap = True

            textbox2 = slide.shapes.add_textbox(
                Inches(10.4), Inches(6.7), Inches(1.5), Inches(0.5)
            )
            textbox2.text_frame.paragraphs[0].text = "Itemized Summary"
            textbox2.text_frame.paragraphs[0].font.name = "Roboto"
            textbox2.text_frame.paragraphs[0].font.size = Pt(11)
            textbox2.text_frame.paragraphs[0].font.color.rgb = RGBColor(72, 88, 95)
            textbox2.text_frame.word_wrap = True

        # Check if the example text fits on a single slide
        max_chars_per_slide = 3000
        for ki in request_body:
            title = ki["title"]
            summary = ki["summary"]
            image_url = ki["image"]
            if len(summary) <= max_chars_per_slide:
                # Text fits on a single slide
                summary = summary.strip()
                add_new_slide(title, summary, image_url)
            else:
                # Text does not fit on a single slide, split it into multiple slides
                sentences = summary.split(".")
                current_slide_text = ""
                for sentence in sentences:
                    if (
                        len(current_slide_text) + len(sentence) + 1
                        > max_chars_per_slide
                    ):
                        # Current slide is full, add a new slide with the accumulated text
                        current_slide_text = current_slide_text.strip()
                        add_new_slide(title, current_slide_text, image_url)
                        current_slide_text = ""
                    current_slide_text += sentence + ". "
                if current_slide_text:
                    # Add the remaining text to a new slide
                    current_slide_text = current_slide_text.strip()
                    add_new_slide(title, current_slide_text, image_url)

        # Thank You page
        ######################
        slide_layout = root.slide_layouts[5]  # Title and content layout
        slide = root.slides.add_slide(slide_layout)
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        # Add background image
        img_path = "app/static/ppt_images/thank_you.jpg"
        pic = slide.shapes.add_picture(
            img_path, 0, 0, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Set title text
        title_shape = slide.shapes.title
        title_shape.text = "Thank you for the download"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            89, 100, 116
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(22)  # Set title font size
        title_shape.text_frame.paragraphs[0].font.bold = True
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"

        # Move 0.2 inches to the right horizontally
        title_shape.left = Inches(4.24)
        title_shape.top = Inches(4.19)  # Move 3 inches down vertically
        title_shape.width = Inches(4.52)  # Set the width to 4 inches
        title_shape.height = Inches(0.45)  # Set the width to 2 inches
        # Saving file

        timestamp = datetime.utcnow().timestamp()
        # root.save(f"app/ppt_outputs/Output_{timestamp}.pptx")
        # return f"ppt_outputs\Output_{timestamp}.pptx"

        file_name = f"itemized_summary_{timestamp}.pptx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, file_name
        )
        root.save(file_path)

        return file_path

    def create_itemized_summary_docx(self, request_body):
        """
        The `create_itemized_summary_docx` function creates a Microsoft Word document with itemized
        summaries based on the provided request body.
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents an item and contains the following keys:
        
        Returns:
          the file path of the created Word document.
        """

        # Create a new document
        document = Document()

        # Add a paragraph with the document title
        document.add_paragraph("Itemized Summary", style="Title")

        def create_summary(title="", summary="", image_url=None, link=None):
            # Add a heading for the item
            h = document.add_heading()
            run = h.add_run(title)
            font = run.font
            font.size = Pt(16)

            document.add_paragraph()

            # If there is an image url, add an image
            if image_url:
                # Download the image from the URL
                response = requests.get(image_url)
                image_content = BytesIO(response.content)
                document.add_picture(image_content, width=Inches(2), height=Inches(2))

            last_paragraph = document.paragraphs[-1]
            last_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

            # Add a paragraph for the summary
            p = document.add_paragraph()
            run = p.add_run(summary)
            font = run.font
            font.size = Pt(12)

            # Add a clickable link at the end of the summary
            if link:
                p = document.add_paragraph()
                add_hyperlink(p, link, link)

            document.add_paragraph()

        # Add a paragraph for each item in the request body
        for idx, ki in enumerate(request_body):
            # Add a page break if the KI Summary is not the first one
            if idx:
                # Add a page break so that each summary starts on a new page
                p = document.add_paragraph()
                run = p.add_run()
                run.add_break(WD_BREAK.PAGE)

            ki_title = ki["title"]
            ki_summary = ki["summary"]
            ki_image_url = ki["image"]
            ki_link = ki["link"]

            create_summary(ki_title, ki_summary, ki_image_url, ki_link)

        # Save the document
        timestamp = datetime.utcnow().timestamp()
        file_name = f"Output_{timestamp}.docx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, file_name
        )
        document.save(file_path)

        return file_path

    def create_itemized_summary_excel(self, request_body):
        """
        The function `create_itemized_summary_excel` creates an Excel file with an itemized summary
        based on the provided request body.
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents a file record and contains the following keys:
        
        Returns:
          the file path of the generated Excel file.
        """
        print("Itemized summary request body : ", request_body)
        workbook = Workbook()
        sheet = workbook.active
        headers = ["Sl No.", "Title", "Summary", "Link", "Tag", "Date"]
        sheet.append(headers)
        # adding data to workbook
        for file_record in request_body:
            row = [
                file_record.get("seq_number", 0) + 1,
                file_record.get("title", ""),
                file_record.get("summary", ""),
                file_record.get("link", ""),
                file_record.get("tag", ""),
                file_record.get("pub_date", ""),
            ]
            sheet.append(row)
            # print(row)

        timestamp = datetime.utcnow().timestamp()
        file_name = f"itemized_summary_{timestamp}.xlsx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, file_name
        )
        workbook.save(file_path)
        workbook.close()
        return file_path

    def create_highlights_summary_excel(self, request_body):
        """
        The function `create_highlights_summary_excel` creates an Excel file with a summary of
        highlights based on the provided request body.
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents a file record and contains the following keys:
        
        Returns:
          the file path of the created Excel file.
        """
        print(request_body)
        workbook = Workbook()
        sheet = workbook.active
        # adding headers
        headers = ["Sl No.", "Title", "Link", "Sentences and Key phrases"]
        sheet.append(headers)
        sheet.cell(2, 4).value = "Sentence"
        sheet.cell(2, 5).value = "Key phrase"

        # adding data to workbook
        j = 3
        for i, file_record in enumerate(request_body):
            print(file_record)
            row = [
                file_record.get("seq_number", 0) + 1,
                file_record.get("title", ""),
                file_record.get("link", ""),
            ]
            sheet.append(row)
            highlights = file_record["highlights"]
            for i, highlight in enumerate(highlights):
                print(highlight)
                sheet.cell(row=j, column=4).value = highlight.get("Sentence", "")
                sheet.cell(row=j, column=5).value = highlight.get("KeyPhrases", "")
                j += 1

            # print(row)

        # return f"excel_outputs\Output_{timestamp}.xlsx"
        timestamp = datetime.utcnow().timestamp()
        file_name = f"highlights_summary_{timestamp}.xlsx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_XLSX_DOWNLOAD_FOLDER, file_name
        )
        workbook.save(file_path)
        workbook.close()

        return file_path

    def create_highlights_summary_ppt(self, request_body):
        """
        The `create_highlights_summary_ppt` function creates a PowerPoint presentation with a title
        page, content pages, and a thank you page based on the provided request body.
        Ref for slide types:
            0 -> title and subtitle
            1 -> title and content
            2 -> section header
            3 -> two content
            4 -> Comparison
            5 -> Title only
            6 -> Blank
            7 -> Content with caption
            8 -> Pic with caption
        
        Args:
          request_body: The `request_body` parameter is a JSON object that contains the data needed to
        create the PowerPoint presentation. It should have the following structure:
        
        Returns:
          the file path of the created PowerPoint presentation.
        """

        # Creating presentation object
        root = Presentation()

        # Set slide width and height
        slide_width = 11887200
        slide_height = 6686550
        root.slide_width = slide_width
        root.slide_height = slide_height

        # Heading Page
        #############################

        # Creating slide layout
        first_slide_layout = root.slide_layouts[5]

        # Creating slide object to add
        slide = root.slides.add_slide(first_slide_layout)

        # Set slide dimensions
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        left = top = 0
        img_path = "app/static/ppt_images/cover_export.jpg"
        pic = slide.shapes.add_picture(
            img_path, left, top, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Adding title and subtitle in slide
        # i.e. first page of slide
        title_shape = slide.shapes.title
        title_shape.text = "Highlights Summary"
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            255, 255, 255
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(43)  # Set title font size

        # Change the position of the title box
        title_shape.left = Inches(0.85)
        title_shape.top = Inches(2.52)
        title_shape.width = Inches(4)  # Set the width to 4 inches
        title_shape.height = Inches(2)  # Set the width to 2 inches
        title_shape.text_frame.paragraphs[0].font.bold = True

        # Content pages
        ##########################

        # Function to add a new slide with given title and content

        def add_new_slide(title, content, image=""):
            slide_layout = root.slide_layouts[5]
            slide = root.slides.add_slide(slide_layout)
            slide.slide_width = slide_width
            slide.slide_height = slide_height

            # Add background image
            img_path = "app/static/ppt_images/inside_export.jpg"
            pic = slide.shapes.add_picture(
                img_path, 0, 0, width=slide_width, height=slide_height
            )

            # This moves it to the background
            slide.shapes._spTree.remove(pic._element)
            slide.shapes._spTree.insert(2, pic._element)

            # Set title text
            title_shape = slide.shapes.title
            title_shape.text = title.strip()
            # title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(255, 255, 255)  # Set title color to white
            title_shape.text_frame.paragraphs[0].font.size = Pt(
                24
            )  # Set title font size
            # Set title font to Roboto
            title_shape.text_frame.paragraphs[0].font.name = "Roboto"
            title_shape.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
            title_shape.text_frame.paragraphs[0].font.bold = True

            # Move 0.25 inches to the right horizontally
            title_shape.left = Inches(0.28)
            title_shape.top = Inches(0.26)  # Move 0.16 inches down vertically
            title_shape.width = Inches(11)  # Set the width to 4 inches
            title_shape.height = Inches(0.5)  # Set the width to 0.75 inches

            # Set the width and height for the image
            image_width = Inches(3)
            image_height = Inches(3)

            if image:
                # Download the image from the URL
                response = requests.get(image)
                image_content = BytesIO(response.content)

                # Add the image to the slide
                slide.shapes.add_picture(
                    image_content,
                    Inches(0.35),
                    Inches(1.3),
                    width=image_width,
                    height=image_height,
                )

            textbox = slide.shapes.add_textbox(
                Inches(10.4), Inches(6.7), Inches(2), Inches(0.5)
            )
            textbox.text_frame.paragraphs[0].text = "Highlights Summary"
            textbox.text_frame.paragraphs[0].font.name = "Roboto"
            textbox.text_frame.paragraphs[0].font.size = Pt(11)
            textbox.text_frame.paragraphs[0].font.bold = True
            textbox.text_frame.paragraphs[0].font.color.rgb = RGBColor(72, 88, 95)
            textbox.text_frame.word_wrap = True

            if image:
                textbox2 = slide.shapes.add_textbox(
                    Inches(3.7), Inches(1), Inches(8), Inches(5.3)
                )
            else:
                textbox2 = slide.shapes.add_textbox(
                    Inches(0.28), Inches(1), Inches(12), Inches(5.3)
                )
            text_frame = textbox2.text_frame
            for value in enumerate(content):
                keys = list(value[1].keys())
                text = value[1][keys[1]]
                keywords = value[1][keys[0]]

                bullet_point = "\u2022"

                allText = bullet_point + " " + text
                sentence = allText.split(keywords.lower())
                para = text_frame.add_paragraph()
                iIndex = 0
                for phrase in sentence:
                    run1 = para.add_run()
                    run1.text = phrase
                    run1.font.name = "Roboto"
                    run1.font.size = Pt(13)

                    if iIndex != len(sentence) - 1:
                        run2 = para.add_run()
                        run2.text = keywords.lower()
                        run2.font.name = "Roboto"
                        run2.font.size = Pt(13)
                        run2.font.color.rgb = RGBColor(0, 0, 255)

                    iIndex = iIndex + 1
                #  Add bullet points to the text box
            textbox2.text_frame.word_wrap = True

        def divide_array(arr, subarray_length):
            divided_array = []
            for i in range(0, len(arr), subarray_length):
                divided_array.append(arr[i : i + subarray_length])
            return divided_array

        for ki in request_body:
            title = ki["title"]
            highlights = ki["highlights"]
            image_url = ki["image"]
            highlights_sub_array = divide_array(highlights, 15)
            # add_new_slide(title, highlights, image_url)
            for i in highlights_sub_array:
                # print(i)
                add_new_slide(title, i, image_url)

        # Thank You page
        ######################
        slide_layout = root.slide_layouts[5]  # Title and content layout
        slide = root.slides.add_slide(slide_layout)
        slide.slide_width = slide_width
        slide.slide_height = slide_height

        # Add background image
        img_path = "app/static/ppt_images/thank_you.jpg"
        pic = slide.shapes.add_picture(
            img_path, 0, 0, width=slide_width, height=slide_height
        )

        # This moves it to the background
        slide.shapes._spTree.remove(pic._element)
        slide.shapes._spTree.insert(2, pic._element)

        # Set title text
        title_shape = slide.shapes.title
        title_shape.text = "Thank you for the download"
        title_shape.text_frame.paragraphs[0].font.color.rgb = RGBColor(
            89, 100, 116
        )  # Set title color to white
        title_shape.text_frame.paragraphs[0].font.size = Pt(22)  # Set title font size
        title_shape.text_frame.paragraphs[0].font.bold = True
        # Set title font to Roboto
        title_shape.text_frame.paragraphs[0].font.name = "Roboto"

        # Move 0.2 inches to the right horizontally
        title_shape.left = Inches(4.24)
        title_shape.top = Inches(4.19)  # Move 3 inches down vertically
        title_shape.width = Inches(4.52)  # Set the width to 4 inches
        title_shape.height = Inches(0.45)  # Set the width to 2 inches
        # Saving file

        timestamp = datetime.utcnow().timestamp()
        file_name = f"highlights_summary_{timestamp}.pptx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_PPTX_DOWNLOAD_FOLDER, file_name
        )
        root.save(file_path)

        return file_path

    def create_highlights_summary_docx(self, request_body):
        """
        The function `create_highlights_summary_docx` creates a Word document with a summary of
        highlights, including titles, images, and bullet points.
        
        Args:
          request_body: The `request_body` parameter is a list of dictionaries. Each dictionary
        represents an item with the following keys:
        
        Returns:
          the file path of the created Word document (docx) containing the highlights summary.
        """

        # Create a new document
        document = Document()

        # Add a paragraph with the document title
        document.add_paragraph("Highlights Summary", style="Title")

        def create_summary(title="", highlights=[], image_url=None):
            # Add a heading for the item
            h = document.add_heading()
            run = h.add_run(title)
            font = run.font
            font.size = Pt(16)

            document.add_paragraph()

            # If there is an image url, add an image
            if image_url:
                # Download the image from the URL
                response = requests.get(image_url)
                image_content = BytesIO(response.content)
                document.add_picture(image_content, width=Inches(2), height=Inches(2))

            last_paragraph = document.paragraphs[-1]
            last_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER

            # Add a highlight bullet points
            for highlight in highlights:
                keyphrase = highlight["KeyPhrases"]
                highlight_sentence = highlight["Sentence"]

                keyphrase_index = highlight_sentence.lower().find(keyphrase.lower())
                keyphrase_length = len(keyphrase)
                start = keyphrase_index
                end = keyphrase_index + keyphrase_length

                highlight_start = highlight_sentence[:start]
                highlight_keyphrase = highlight_sentence[start:end]
                highlight_end = highlight_sentence[end:]

                p = document.add_paragraph()

                p.add_run(highlight_start)
                p.add_run(highlight_keyphrase)
                p.add_run(highlight_end)

                p.keep_with_next = True
                p.style = "List Bullet"
                p.runs[0].font.size = Pt(12)
                p.runs[1].font.size = Pt(12)
                p.runs[2].font.size = Pt(12)

                # Color the keyphrase with a different color
                p.runs[1].font.color.rgb = docx.shared.RGBColor(0, 0, 255)

            document.add_paragraph()

        # Add a paragraph for each item in the request body
        for ki in request_body:
            ki_title = ki["title"]
            ki_highlights = ki["highlights"]
            ki_image_url = ki["image"]

            create_summary(ki_title, ki_highlights, ki_image_url)

        # Save the document
        timestamp = datetime.utcnow().timestamp()
        file_name = f"Highlights_Output_{timestamp}.docx"

        # Ensure that the user image upload folder exists
        os.makedirs(Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, exist_ok=True)

        file_path = os.path.join(
            Config.USER_SUMMARY_DOCX_DOWNLOAD_FOLDER, file_name
        )
        document.save(file_path)

        return file_path

    def _summarize_sumy_text_rank(
        self, ki_ids: Iterable[str], sentence_count: int
    ) -> Generator[str, int, bool]:
        """
        Summarizes the descriptions of KIs one-by-one using Text Rank method from sumy module
        Sends them back one by one
        """
        ki_collection = Config.MONGO_KI_COLLECTION

        m_db = MongoClient.connect()

        # Convert kiIds to a list of ObjectIDs
        ki_ids_object_id = list(map(ObjectId, ki_ids))

        ki_iterable = m_db[ki_collection].find({"_id": {"$in": ki_ids_object_id}})

        summarizer = TextRankSummarizer()

        for idx, ki in enumerate(ki_iterable):
            ki_description = ""

            if not ki:
                yield ki_description, idx, False

            ki_description = ki["description"]

            # parser = PlaintextParser.from_string(
            #     ki_description, SummaryService.PUNKT_SENTENCE_TOKENIZER)

            parser = PlaintextParser.from_string(ki_description, Tokenizer("english"))

            summary = summarizer(parser.document, sentence_count)
            text_summary = ""
            for sentence in summary:
                text_summary += str(sentence)

            # yield text_summary, True
            yield text_summary, idx, True

# Helper functions START

# NOTE: Main keyphrase function
def key_phrases(para):
    """
    The `key_phrases` function extracts key phrases from a given paragraph of text.
    
    Args:
      para: The "para" parameter is a string that represents a paragraph of text.
    
    Returns:
      a dictionary with the following keys:
    - "suc": A boolean value indicating whether the function was successful or not.
    - "out": A list of topic sentences with their corresponding key phrases.
    - "st_time": The start time of the function execution.
    - "ed_time": The end time of the function execution.
    """
    try:
        print("para", para)
        para = _scrapper_text_clean(para)
        st_time = datetime.utcnow()
        r = Rake(punctuations="")
        regexTwo = re.compile('"')
        regexOne = re.compile("â€")
        global tokenizer
        conca = ""
        for sen_ in para:
            conca = conca + sen_

        sentences = SummaryService.tokenizer.tokenize(conca)
        topic_sentences = []

        for sentence in sentences:
            if len(sentence) < 30:
                continue

            elif re.search("=", sentence):
                continue

            elif re.search(re.escape("+"), sentence):
                continue

            elif re.search("/", sentence):
                continue

            else:
                r.extract_keywords_from_text(sentence)
                keyphrases = r.get_ranked_phrases()[0]

                if regexOne.search(keyphrases) != None:
                    print("PHRASES : ", r.get_ranked_phrases())
                    phrase = r.get_ranked_phrases()
                    if len(phrase) > 1:
                        keyphrases = phrase[1]

                if regexTwo.search(keyphrases) != None:
                    print("PHRASES : ", r.get_ranked_phrases())
                    phrase = r.get_ranked_phrases()
                    if len(phrase) > 1:
                        keyphrases = phrase[1]

                keyphrases = _acronyms_and_capital(sentence, keyphrases)

                # re used for removing URL
                keyphrases = re.sub(
                    r"\w+:\/{2}[\d\w-]+(\.[\d\w-]+)*(?:(?:\/[^\s/]*))*", "", keyphrases
                )
                keyphrases = re.sub(
                    r"^https?:\/\/.*[\r\n]*", "", keyphrases, flags=re.MULTILINE
                )

                # re used for removing special char from the string
                keyphrases = re.sub("[^a-zA-Z0-9 \n\.\-\$\%\&\@\:]", "", keyphrases)
                keyphrases = keyphrases.strip()
                length = len(keyphrases)
                # print("Key phrases length : ",length)
                # print("Key phrases : ", keyphrases)
                if length != 0:
                    if keyphrases[0] == ".":
                        keyphrases = keyphrases[1:length]
                    keyphrases = keyphrases.strip()
                    keyphrases = keyphrases[0].upper() + keyphrases[1:]
                    keyphrases = _remove_space_number(keyphrases)

                sentence = re.sub(r"(?<=[.,])(?=[^\s])", r" ", sentence)
                sentence = _remove_space_number(sentence)
                sentence = sentence.replace(" ,", ",")
                sentence = sentence.replace(" .", ".")

                length = len(keyphrases)
                if length != 0:
                    if keyphrases[-1] == ".":
                        keyphrases = keyphrases[0 : length - 1]

                topic_sentence = {"KeyPhrases": keyphrases, "Sentence": sentence}
                topic_sentences.append(topic_sentence)

        topic_sentences = {
            frozenset(item.items()): item for item in topic_sentences
        }.values()
        topic_sentences = _appending_key_phrase(list(topic_sentences))

        topic_sentences = {
            frozenset(item.items()): item for item in topic_sentences
        }.values()

        ed_time = datetime.utcnow()

        print("Topic sentences", list(topic_sentences))
        if not len(list(topic_sentences)) > 0:
            # raise Exception("KeyPhrase Model didn't return anything")

            # If manual highlight generation fails then use LLM highlight generation
            return generate_highlights(para)

        return {
            "suc": True,
            "out": list(topic_sentences),
            "st_time": st_time,
            "ed_time": ed_time,
        }

    except Exception as e:
        Common.exception_details("summaryService.key_phrases", e)
        return generate_highlights(para)

# NOTE: Function to clean the text
def _scrapper_text_clean(text):
    """
    The function `_scrapper_text_clean` takes in a text and removes certain specified texts, removes
    square brackets with numbers, and removes extra spaces to clean the text.
    
    Args:
      text: The `text` parameter is a string that represents the text that needs to be cleaned.
    
    Returns:
      the cleaned text after removing certain texts and special characters.
    """
    for i in SummaryService.texts_to_be_removed:
        text = text.replace(i, "")
    text = re.sub(r"\[[0-9]+\]", "", text)
    text = " ".join(text.split())
    return text

# NOTE: Function used to remove club sentences with same keyphrases
def _appending_key_phrase(dicts):
    """
    The function `_appending_key_phrase` takes a list of dictionaries as input, where each dictionary has a
    "KeyPhrases" key and a "Sentence" key. It iterates through the list and combines sentences that have
    the same key phrases, creating a new list of dictionaries with the combined sentences.
    
    Args:
      dicts: The parameter "dicts" is a list of dictionaries. Each dictionary in the list represents a
    sentence and its corresponding key phrases. Each dictionary has two key-value pairs: "KeyPhrases"
    and "Sentence". "KeyPhrases" is a string representing the key phrases of the sentence, and
    
    Returns:
      a list of dictionaries. Each dictionary contains a "KeyPhrases" key and a "Sentence" key.
    """
    len_ = len(dicts)
    done = []
    dictNew = []
    for i in range(len_):
        sentence = ""
        cnt = 0
        keyPhrasesOut = dicts[i]["KeyPhrases"]
        if keyPhrasesOut not in done:
            done.append(keyPhrasesOut)
            for j in range(i + 1, len_):
                keyPhrasesIn = dicts[j]["KeyPhrases"]
                if keyPhrasesOut == keyPhrasesIn:
                    sentence = sentence + " " + dicts[j]["Sentence"]
            sentence = dicts[i]["Sentence"] + " " + sentence
            dictNew.append({"KeyPhrases": dicts[i]["KeyPhrases"], "Sentence": sentence})
        else:
            continue
    return dictNew

# NOTE: Function used to find and capitalize acronyms
def _acronyms_and_capital(sentence, keyphrases):
    """
    The function `_acronyms_and_capital` takes a sentence and a list of keyphrases as input, and returns a
    modified version of the sentence where acronyms are converted to uppercase and capital words are
    converted to title case.
    
    Args:
      sentence: The sentence parameter is a string that represents a sentence or a phrase. It can
    contain words, acronyms, and capital words.
      keyphrases: The `keyphrases` parameter is a string that contains the key phrases or words that you
    want to modify based on the acronyms and capital words found in the `sentence`.
    
    Returns:
      The function `_acronyms_and_capital` returns a modified version of the `keyphrases` string where
    acronyms are converted to uppercase and capital words are converted to title case.
    """
    # regular expression to find acronyms
    rx = r"\b[A-Z](?=([&.]?))(?:\1[A-Z])+\b"
    # regular expression to find capital words
    capital = re.findall(r"(?<!^)[A-Z][a-z]+", sentence)
    # getting acronyms
    acronyms = [x.group() for x in re.finditer(rx, sentence)]
    # converting capital and acronyms to lower case
    capital = [element.lower() for element in capital]
    acronyms = [element.lower() for element in acronyms]

    afterAcronyms = ""
    afterCapital = ""

    words = keyphrases.split()

    for word in words:
        if word not in acronyms:
            afterAcronyms += " " + word
        else:
            afterAcronyms += " " + word.upper()

    words = afterAcronyms.split()

    for word in words:
        length = len(word)
        lastCharacter = word[length - 1]

        # regular expression to check if it's a special character
        regex = re.compile("[@_!#$%^&*()<>?/\|}{~:.,]")

        if regex.search(lastCharacter) == None:
            if word not in capital:
                afterCapital += " " + word
            else:
                afterCapital += " " + word.title()

        else:
            word = word[0 : length - 1]
            if len(word) == 0:
                afterCapital += lastCharacter
            else:
                if word not in capital:
                    afterCapital += " " + word
                else:
                    afterCapital += " " + word.title() + lastCharacter

    return afterCapital

# NOTE: Function to remove space between numbers
def _remove_space_number(str_):
    """
    The function `_remove_space_number` removes spaces between numbers and special characters in a given
    string.
    
    Args:
      str_: The input string from which you want to remove spaces between numbers and special
    characters.
    
    Returns:
      a modified version of the input string where any occurrences of numbers separated by spaces and
    non-word characters are replaced with the same numbers without any spaces.
    """
    find = re.findall(r"\d+\W\s+\d+|\d+\s+\W\d+|\d+\s+\W\s+\d+", str_)
    for num in find:
        new = num.replace(" ", "")
        str_ = str_.replace(num, new)
    return str_

# Helper functions END